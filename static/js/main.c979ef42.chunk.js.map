{"version":3,"sources":["components/Tile.js","components/Dijkstra.js","components/Prim.js","components/PopUp.js","components/Grid.js","components/Header.js","App.js","index.js"],"names":["Tile","setClassName","wall","start","end","path","explored","exploring","x","this","props","y","handleMouseEnter","handleMouseDown","handleMouseUp","name","className","onMouseEnter","e","onMouseDown","onMouseUp","Component","MinHeap","root","getRoot","heap","length","getArrayForm","insertNode","node","push","currIndex","parentIndex","Math","floor","distance","deleteRoot","pop","leftChildIndex","rightChildIndex","leftChildExists","rightChildExists","swappingWithLeft","dijkstra","startX","startY","endX","endY","grid","a","neighbour","moves","Heap","map","row","tile","Infinity","tileState","getNeighbours","width","height","neighbours","unvisited","localeCompare","includes","previousTile","toExplore","i","state","currentTile","explore","weight","prim","random","adjacentEmptyGap","countGaps","currentRoot","PopUp","clickHandler","toggle","onClick","Grid","preventDefault","isHoldingStart","currentEndingPosition","isHoldingEnd","currentStartingPosition","isHoldingWall","updatedArray","updatedTileArray","setState","currentGridTiles","currentlyAnimating","resetTileArray","generateEmptyTileArray","cmd","tileArray","yRow","xCol","key","emptyTileArray","dijkstraButtonClick","visualizePath","generateMazeButtonClick","getPath","cloneGrid","slice","responseDijkstra","createMaze","timer","ms","Promise","res","setTimeout","move","newArray","JSON","parse","stringify","responseMaze","displayHelp","seeHelp","mazeGenerated","Header","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c979ef42.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Tile.css\";\r\n\r\nexport default class Tile extends Component {\r\n  setClassName = (wall, start, end, path, explored, exploring) => {\r\n    if (wall) return \"wall\";\r\n    else if (start) return \"start\";\r\n    else if (end) return \"end\";\r\n    else if (path) return \"path\";\r\n    else if (explored) return \"explored\";\r\n    else if (exploring) return \"exploring\";\r\n    else return \"empty\";\r\n  };\r\n  render() {\r\n    const x = this.props.x;\r\n    const y = this.props.y;\r\n    const handleMouseEnter = this.props.handleMouseEnter;\r\n    const handleMouseDown = this.props.handleMouseDown;\r\n    const handleMouseUp = this.props.handleMouseUp;\r\n    const name = this.setClassName(\r\n      this.props.wall,\r\n      this.props.start,\r\n      this.props.end,\r\n      this.props.path,\r\n      this.props.explored,\r\n      this.props.exploring\r\n    );\r\n    return (\r\n      <div\r\n        className={name}\r\n        onMouseEnter={(e) => {\r\n          handleMouseEnter(x, y, e);\r\n        }}\r\n        onMouseDown={(e) => {\r\n          handleMouseDown(x, y, e);\r\n        }}\r\n        onMouseUp={(e) => {\r\n          handleMouseUp(e);\r\n        }}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","//The Dijkstra function will return an array of objects of the format {x: xpos, y: ypos, state: currentState} to indicate the next tile and what animation to render.\r\n// currentState will be one of: \"explored\"(the \"visited\" tiles), \"exploring\"(the current tile being examined), \"path\" (one of the tiles that leads the start node to the exit node\r\n// through an optimal path calculated by the algorithm)\r\n//The grid will receive this array instantly and then render the visualization. In other words, the visualization is pre-calculated.\r\n\r\nclass MinHeap {\r\n  //data structure for keeping track of unvisited nodes and the order in which they are visited\r\n  constructor(root) {\r\n    this.heap = [root];\r\n  }\r\n  getRoot = () => this.heap[0];\r\n\r\n  length = () => this.heap.length;\r\n\r\n  getArrayForm = () => this.heap;\r\n\r\n  insertNode = (node) => {\r\n    if (this.heap.length === 0) {\r\n      this.heap.push(node);\r\n    } else {\r\n      this.heap.push(node); //inserts at next available leaf node\r\n      let currIndex = this.heap.length - 1;\r\n      let parentIndex = Math.floor((currIndex - 1) / 2);\r\n      while (\r\n        parentIndex >= 0 &&\r\n        this.heap[parentIndex].distance > this.heap[currIndex].distance\r\n      ) {\r\n        //fix heap\r\n        //SWAP\r\n        [this.heap[parentIndex], this.heap[currIndex]] = [\r\n          this.heap[currIndex],\r\n          this.heap[parentIndex],\r\n        ];\r\n        currIndex = parentIndex;\r\n        parentIndex = Math.floor((currIndex - 1) / 2);\r\n      }\r\n    }\r\n  };\r\n\r\n  deleteRoot = () => {\r\n    if (this.heap.length === 0) {\r\n      return;\r\n    } else if (this.heap.length === 1) {\r\n      this.heap.length = 0;\r\n    } else {\r\n      this.heap[0] = this.heap[this.heap.length - 1];\r\n      this.heap.pop();\r\n      let currIndex = 0;\r\n      let leftChildIndex = currIndex * 2 + 1;\r\n      let rightChildIndex = currIndex * 2 + 2;\r\n      let leftChildExists = leftChildIndex < this.heap.length;\r\n      let rightChildExists = rightChildIndex < this.heap.length;\r\n      while (\r\n        (leftChildExists &&\r\n          this.heap[currIndex].distance > this.heap[leftChildIndex].distance) ||\r\n        (rightChildExists &&\r\n          this.heap[currIndex].distance > this.heap[rightChildIndex].distance)\r\n      ) {\r\n        //fix heap after deletion\r\n        let swappingWithLeft = true; //true: swap with left, false: swap with right\r\n        if (\r\n          rightChildExists &&\r\n          this.heap[rightChildIndex].distance <\r\n            this.heap[leftChildIndex].distance\r\n        ) {\r\n          swappingWithLeft = false;\r\n        }\r\n\r\n        if (swappingWithLeft) {\r\n          [this.heap[currIndex], this.heap[leftChildIndex]] = [\r\n            this.heap[leftChildIndex],\r\n            this.heap[currIndex],\r\n          ];\r\n          currIndex = leftChildIndex;\r\n        } else {\r\n          [this.heap[currIndex], this.heap[rightChildIndex]] = [\r\n            this.heap[rightChildIndex],\r\n            this.heap[currIndex],\r\n          ];\r\n          currIndex = rightChildIndex;\r\n        }\r\n\r\n        leftChildIndex = currIndex * 2 + 1;\r\n        rightChildIndex = currIndex * 2 + 2;\r\n        leftChildExists = leftChildIndex < this.heap.length;\r\n        rightChildExists = rightChildIndex < this.heap.length;\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport const dijkstra = async (startX, startY, endX, endY, grid) => {\r\n  let moves = [];\r\n  let Heap = new MinHeap(grid[startY][startX]);\r\n\r\n  grid.map((row) => {\r\n    row.map((tile) => {\r\n      if (tile.x !== startX || tile.y !== startY) {\r\n        tile.distance = Infinity;\r\n      }\r\n      return (tile.tileState = \"unexplored\");\r\n    });\r\n    return grid;\r\n  });\r\n\r\n  const getNeighbours = (x, y) => {\r\n    const width = grid[0].length;\r\n    const height = grid.length;\r\n    let neighbours = [],\r\n      unvisited = Heap.getArrayForm();\r\n    //UP\r\n    if (\r\n      y - 1 >= 0 &&\r\n      !grid[y - 1][x].wall &&\r\n      grid[y - 1][x].tileState.localeCompare(\"explored\") !== 0 &&\r\n      !grid[y - 1][x].start &&\r\n      !unvisited.includes(grid[y - 1][x])\r\n    ) {\r\n      neighbours.push(grid[y - 1][x]);\r\n    }\r\n    //RIGHT\r\n    if (\r\n      x + 1 < width &&\r\n      !grid[y][x + 1].wall &&\r\n      grid[y][x + 1].tileState.localeCompare(\"explored\") !== 0 &&\r\n      !grid[y][x + 1].start &&\r\n      !unvisited.includes(grid[y][x + 1])\r\n    ) {\r\n      neighbours.push(grid[y][x + 1]);\r\n    }\r\n    //DOWN\r\n    if (\r\n      y + 1 < height &&\r\n      !grid[y + 1][x].wall &&\r\n      grid[y + 1][x].tileState.localeCompare(\"explored\") !== 0 &&\r\n      !grid[y + 1][x].start &&\r\n      !unvisited.includes(grid[y + 1][x])\r\n    ) {\r\n      neighbours.push(grid[y + 1][x]);\r\n    }\r\n    //LEFT\r\n    if (\r\n      x - 1 >= 0 &&\r\n      !grid[y][x - 1].wall &&\r\n      grid[y][x - 1].tileState.localeCompare(\"explored\") !== 0 &&\r\n      !grid[y][x - 1].start &&\r\n      !unvisited.includes(grid[y][x - 1])\r\n    ) {\r\n      neighbours.push(grid[y][x - 1]);\r\n    }\r\n    return neighbours;\r\n  };\r\n\r\n  let neighbours = getNeighbours(startX, startY);\r\n  for (let neighbour in neighbours) {\r\n    neighbours[neighbour].distance = 1;\r\n    neighbours[neighbour].previousTile = grid[startY][startX];\r\n    Heap.insertNode(neighbours[neighbour]);\r\n  }\r\n  Heap.deleteRoot();\r\n\r\n  //Heap currently contains the (up to) 4 neighbours of start node\r\n  const explore = () => {\r\n    while (\r\n      grid[endY][endX].tileState.localeCompare(\"explored\") !== 0 &&\r\n      Heap.length() > 0\r\n    ) {\r\n      const toExplore = Heap.length();\r\n      for (let i = 0; i < toExplore; i++) {\r\n        let root = Heap.getRoot();\r\n        root.tileState = \"exploring\";\r\n        moves.push({ x: root.x, y: root.y, state: \"exploring\" });\r\n        const neighbours = getNeighbours(root.x, root.y);\r\n\r\n        if (neighbours.includes(grid[endY][endX])) {\r\n          //if end has been found, start exiting the loop\r\n          if (grid[endY][endX].distance > root.distance + 1) {\r\n            grid[endY][endX].distance = root.distance + 1;\r\n            grid[endY][endX].previousTile = root;\r\n          }\r\n          let currentTile = grid[endY][endX].previousTile;\r\n          while (currentTile.x !== startX || currentTile.y !== startY) {\r\n            currentTile.tileState = \"path\";\r\n            moves.push({ x: currentTile.x, y: currentTile.y, state: \"path\" });\r\n            currentTile = currentTile.previousTile;\r\n          }\r\n          return;\r\n        }\r\n        for (let neighbour in neighbours) {\r\n          if (neighbours[neighbour].distance > root.distance + 1) {\r\n            neighbours[neighbour].distance = root.distance + 1;\r\n            neighbours[neighbour].previousTile = root;\r\n          }\r\n          Heap.insertNode(neighbours[neighbour]);\r\n        }\r\n        root.tileState = \"explored\";\r\n        moves.push({ x: root.x, y: root.y, state: \"explored\" });\r\n        Heap.deleteRoot();\r\n      }\r\n    }\r\n\r\n    let currentTile = grid[endY][endX].previousTile;\r\n    while (\r\n      currentTile &&\r\n      (currentTile.x !== startX || currentTile.y !== startY)\r\n    ) {\r\n      currentTile.tileState = \"path\";\r\n      moves.push({ x: currentTile.x, y: currentTile.y, state: \"path\" });\r\n      currentTile = currentTile.previousTile;\r\n    }\r\n  };\r\n  explore();\r\n  return moves;\r\n};\r\n","class MinHeap {\r\n  //data structure for keeping track of unvisited nodes and the order in which they are visited\r\n  constructor(root) {\r\n    this.heap = [root];\r\n  }\r\n  getRoot = () => this.heap[0];\r\n\r\n  length = () => this.heap.length;\r\n\r\n  getArrayForm = () => this.heap;\r\n\r\n  insertNode = (node) => {\r\n    if (this.heap.length === 0) {\r\n      this.heap.push(node);\r\n    } else {\r\n      this.heap.push(node); //inserts at next available leaf node\r\n      let currIndex = this.heap.length - 1;\r\n      let parentIndex = Math.floor((currIndex - 1) / 2);\r\n      while (\r\n        parentIndex >= 0 &&\r\n        this.heap[parentIndex].weight > this.heap[currIndex].weight\r\n      ) {\r\n        //fix heap\r\n        //SWAP\r\n        [this.heap[parentIndex], this.heap[currIndex]] = [\r\n          this.heap[currIndex],\r\n          this.heap[parentIndex],\r\n        ];\r\n        currIndex = parentIndex;\r\n        parentIndex = Math.floor((currIndex - 1) / 2);\r\n      }\r\n    }\r\n  };\r\n\r\n  deleteRoot = () => {\r\n    if (this.heap.length === 0) {\r\n      return;\r\n    } else if (this.heap.length === 1) {\r\n      this.heap.length = 0;\r\n    } else {\r\n      this.heap[0] = this.heap[this.heap.length - 1];\r\n      this.heap.pop();\r\n      let currIndex = 0;\r\n      let leftChildIndex = currIndex * 2 + 1;\r\n      let rightChildIndex = currIndex * 2 + 2;\r\n      let leftChildExists = leftChildIndex < this.heap.length;\r\n      let rightChildExists = rightChildIndex < this.heap.length;\r\n      while (\r\n        (leftChildExists &&\r\n          this.heap[currIndex].weight > this.heap[leftChildIndex].weight) ||\r\n        (rightChildExists &&\r\n          this.heap[currIndex].weight > this.heap[rightChildIndex].weight)\r\n      ) {\r\n        //fix heap after deletion\r\n        let swappingWithLeft = true; //true: swap with left, false: swap with right\r\n        if (\r\n          rightChildExists &&\r\n          this.heap[rightChildIndex].weight < this.heap[leftChildIndex].weight\r\n        ) {\r\n          swappingWithLeft = false;\r\n        }\r\n        if (swappingWithLeft) {\r\n          [this.heap[currIndex], this.heap[leftChildIndex]] = [\r\n            this.heap[leftChildIndex],\r\n            this.heap[currIndex],\r\n          ];\r\n          currIndex = leftChildIndex;\r\n        } else {\r\n          [this.heap[currIndex], this.heap[rightChildIndex]] = [\r\n            this.heap[rightChildIndex],\r\n            this.heap[currIndex],\r\n          ];\r\n          currIndex = rightChildIndex;\r\n        }\r\n\r\n        leftChildIndex = currIndex * 2 + 1;\r\n        rightChildIndex = currIndex * 2 + 2;\r\n        leftChildExists = leftChildIndex < this.heap.length;\r\n        rightChildExists = rightChildIndex < this.heap.length;\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport const prim = async (start, end, grid) => {\r\n  let Heap = new MinHeap(start);\r\n  let moves = [];\r\n  grid.map((row) => {\r\n    row.map((tile) => {\r\n      if (\r\n        !(tile.x === start.x && tile.y === start.y) &&\r\n        !(tile.x === end.x && tile.y === end.y)\r\n      ) {\r\n        tile.weight = Math.random();\r\n        tile.wall = true;\r\n      }\r\n    });\r\n  });\r\n\r\n  const adjacentEmptyGap = (x, y) => {\r\n    const width = grid[0].length;\r\n    const height = grid.length;\r\n    let countGaps = 0;\r\n    //UP\r\n    if (y - 1 >= 0 && !grid[y - 1][x].wall && !grid[y - 1][x].end) {\r\n      countGaps++;\r\n    }\r\n    //RIGHT\r\n    if (x + 1 < width && !grid[y][x + 1].wall && !grid[y][x + 1].end) {\r\n      countGaps++;\r\n    }\r\n    //DOWN\r\n    if (y + 1 < height && !grid[y + 1][x].wall && !grid[y + 1][x].end) {\r\n      countGaps++;\r\n    }\r\n    //LEFT\r\n    if (x - 1 >= 0 && !grid[y][x - 1].wall && !grid[y][x - 1].end) {\r\n      countGaps++;\r\n    }\r\n    return countGaps;\r\n  };\r\n\r\n  const getNeighbours = (x, y) => {\r\n    const width = grid[0].length;\r\n    const height = grid.length;\r\n    let neighbours = [],\r\n      unvisited = Heap.getArrayForm();\r\n    //UP\r\n    if (y - 1 >= 0 && grid[y - 1][x].wall) {\r\n      neighbours.push(grid[y - 1][x]);\r\n    }\r\n    //RIGHT\r\n    if (x + 1 < width && grid[y][x + 1].wall) {\r\n      neighbours.push(grid[y][x + 1]);\r\n    }\r\n    //DOWN\r\n    if (y + 1 < height && grid[y + 1][x].wall) {\r\n      neighbours.push(grid[y + 1][x]);\r\n    }\r\n    //LEFT\r\n    if (x - 1 >= 0 && grid[y][x - 1].wall) {\r\n      neighbours.push(grid[y][x - 1]);\r\n    }\r\n    return neighbours;\r\n  };\r\n\r\n  let currentRoot = Heap.getRoot();\r\n  while (Heap.length !== 0 && currentRoot) {\r\n    Heap.deleteRoot();\r\n    if (adjacentEmptyGap(currentRoot.x, currentRoot.y) <= 1) {\r\n      let neighbours = getNeighbours(currentRoot.x, currentRoot.y);\r\n      for (let neighbour in neighbours) {\r\n        Heap.insertNode(neighbours[neighbour]);\r\n      }\r\n      currentRoot.wall = false;\r\n      moves.push({ x: currentRoot.x, y: currentRoot.y, state: \"exploring\" });\r\n      moves.push({ x: currentRoot.x, y: currentRoot.y, state: \"carveWall\" });\r\n    }\r\n    currentRoot = Heap.getRoot();\r\n  }\r\n  return moves;\r\n};\r\n","import React, { Component } from \"react\";\r\nimport './PopUp.css'\r\n\r\nexport default class PopUp extends Component {\r\n    clickHandler = () => {\r\n        this.props.toggle();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"helpWrapper\">                 \r\n                <div className=\"helpBody\">      \r\n                <div className=\"closeButton\" onClick={() => {this.clickHandler()}}>&times;</div>  \r\n                <br/>        \r\n                    Tips: \r\n                    <br/>\r\n                    <br/>\r\n                    1. Click and drag the start(yellow) and end(red) nodes to move them around\r\n                    <br/>\r\n                    <br/>\r\n                    2. Make your own walls by clicking and dragging on any empty tile. You can erase walls by clicking and dragging on them.\r\n                    <br/>\r\n                    <br/>\r\n                    3. After generating a maze, you can still move the start/end nodes around and over walls. You can also delete the generated walls and add your own.\r\n                    <br/>\r\n                    <br/>\r\n                    4. At any point in time, you can reset the simulation and start from a clean slate.\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from \"react\";\r\nimport Tile from \"./Tile\";\r\nimport {dijkstra} from './Dijkstra'\r\nimport {prim} from './Prim'\r\nimport \"./Grid.css\";\r\nimport PopUp from \"./PopUp\";\r\n\r\nexport default class Grid extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      currentGridTiles: [],\r\n      isHoldingWall: false,\r\n      isHoldingStart: false,\r\n      isHoldingEnd: false,\r\n      currentStartingPosition: { x: 19, y: 7 },\r\n      currentEndingPosition: { x: 29, y: 7 },\r\n      currentlyAnimating: false,\r\n      mazeGenerated: false,\r\n      seeHelp: false\r\n    };\r\n  }\r\n  width = 50; //not part of state because dimensions are fixed..for now\r\n  height = 15;\r\n\r\n  componentDidMount() {\r\n    const emptyTileArray = this.generateEmptyTileArray(\"hard\");\r\n    this.setState({ currentGridTiles: emptyTileArray });\r\n  }\r\n\r\n  handleMouseEnter = (x, y, e) => {\r\n    e.preventDefault();\r\n    if (this.state.isHoldingStart === true && !(x === this.state.currentEndingPosition.x && y === this.state.currentEndingPosition.y)) {\r\n      let updatedArray = this.updatedTileArray(x, y, \"start\");\r\n      this.setState({ currentGridTiles: updatedArray, isHoldingStart: true });\r\n    } else if (this.state.isHoldingEnd === true && !(x === this.state.currentStartingPosition.x && y === this.state.currentStartingPosition.y)) {\r\n      let updatedArray = this.updatedTileArray(x, y, \"end\");\r\n      this.setState({ currentGridTiles: updatedArray, isHoldingEnd: true });\r\n    } else if (this.state.isHoldingWall === true && !(x === this.state.currentStartingPosition.x && y === this.state.currentStartingPosition.y) && !(x === this.state.currentEndingPosition.x && y === this.state.currentEndingPosition.y)) {\r\n      let updatedArray = this.updatedTileArray(x, y, \"manualWall\");\r\n      this.setState({ currentGridTiles: updatedArray, isHoldingWall: true });\r\n    }\r\n  };\r\n\r\n  handleMouseDown = (x, y, e) => {\r\n    e.preventDefault();\r\n    if (!this.state.currentlyAnimating) {\r\n      if (x === this.state.currentStartingPosition.x && y === this.state.currentStartingPosition.y) {\r\n        this.setState({ isHoldingStart: true })\r\n        this.resetTileArray(\"soft\");\r\n      } else if (x === this.state.currentEndingPosition.x && y === this.state.currentEndingPosition.y) {\r\n        this.setState({ isHoldingEnd: true })\r\n        this.resetTileArray(\"soft\");\r\n      } else {\r\n        let updatedArray = this.updatedTileArray(x, y, \"manualWall\");\r\n        this.setState({ currentGridTiles: updatedArray, isHoldingWall: true });\r\n      }  \r\n    }      \r\n  };\r\n\r\n  handleMouseUp = (e) => {\r\n    e.preventDefault();\r\n    this.setState({ isHoldingWall: false, isHoldingStart: false, isHoldingEnd: false });\r\n  };\r\n\r\n\r\n  updatedTileArray(x, y, cmd) {\r\n    let updatedArray = this.state.currentGridTiles.slice();\r\n    if (!cmd.localeCompare(\"start\") && !updatedArray[y][x].wall) { //make the origninal start a regular empty tile\r\n      updatedArray[this.state.currentStartingPosition.y][this.state.currentStartingPosition.x] = {\r\n        ...updatedArray[this.state.currentStartingPosition.y][this.state.currentStartingPosition.x],\r\n        start: false,\r\n      }\r\n      updatedArray[y][x] = {\r\n        ...updatedArray[y][x],\r\n        start: true,\r\n      }\r\n      this.setState({ currentStartingPosition: { x: x, y: y }});\r\n    } else if (!cmd.localeCompare(\"end\") && !updatedArray[y][x].wall) { //make the origninal end a regular empty tile\r\n      updatedArray[this.state.currentEndingPosition.y][this.state.currentEndingPosition.x] = {\r\n        ...updatedArray[this.state.currentEndingPosition.y][this.state.currentEndingPosition.x],\r\n        end: false,\r\n      }\r\n      updatedArray[y][x] = {\r\n        ...updatedArray[y][x],\r\n        end: true,\r\n      }\r\n      this.setState({ currentEndingPosition: { x: x, y: y }});\r\n    } else if (!cmd.localeCompare(\"manualWall\") && !this.state.isHoldingStart && !this.state.isHoldingEnd){\r\n      updatedArray[y][x] = {\r\n        ...updatedArray[y][x],\r\n        wall: !this.state.currentGridTiles[y][x].wall\r\n      };\r\n    } else if (cmd.localeCompare(\"start\") !== 0 && cmd.localeCompare(\"end\") !== 0) {\r\n      let wall = false;\r\n      if (!cmd.localeCompare(\"wall\")) {\r\n        wall = !this.state.currentGridTiles[y][x].wall;\r\n      }\r\n      updatedArray[y][x] = {\r\n        ...updatedArray[y][x],\r\n        wall: wall,\r\n        path: !cmd.localeCompare(\"path\") ? true : false,\r\n        exploring: !cmd.localeCompare(\"exploring\") ? true : false,\r\n        explored: !cmd.localeCompare(\"explored\") ? true : false,\r\n      };\r\n    }\r\n    return updatedArray;\r\n  }\r\n\r\n  generateEmptyTileArray = (cmd) => {\r\n    let tileArray = [];\r\n    for (let yRow = 0; yRow < this.height; yRow++) {\r\n      tileArray[yRow] = [];\r\n      for (let xCol = 0; xCol < this.width; xCol++) {\r\n        const start = this.state.currentStartingPosition;\r\n        const end = this.state.currentEndingPosition;\r\n        tileArray[yRow][xCol] = {\r\n          key: yRow * this.width + xCol,\r\n          x: xCol,\r\n          y: yRow,\r\n          handleMouseEnter: this.handleMouseEnter,\r\n          handleMouseDown: this.handleMouseDown,\r\n          handleMouseUp: this.handleMouseUp,\r\n          wall: !cmd.localeCompare(\"soft\") ? this.state.currentGridTiles[yRow][xCol].wall : false,\r\n          path: false,\r\n          exploring: false,\r\n          explored: false,\r\n          start: start.x === xCol && start.y === yRow ? true : false,\r\n          end: end.x === xCol && end.y === yRow ? true : false,\r\n        };\r\n      }\r\n    }\r\n    return tileArray;\r\n  };\r\n\r\n  resetTileArray = (cmd) => { //cmd: \"soft\" indicates only path/explored tiles are reset, \"hard\" indicates everything other than start/end is reset\r\n    const emptyTileArray = this.generateEmptyTileArray(cmd);\r\n    this.setState({ currentGridTiles: emptyTileArray, currentlyAnimating: false });\r\n  };\r\n\r\n  dijkstraButtonClick = () => {\r\n    if (!this.state.currentlyAnimating){\r\n      this.resetTileArray(\"soft\");\r\n      this.visualizePath(\"findPath\");\r\n    }    \r\n  }\r\n  \r\n  generateMazeButtonClick = () => {\r\n    //this.resetTileArray(\"soft\");\r\n    this.visualizePath(\"generateMaze\");\r\n  }\r\n\r\n  getPath = async () => {\r\n      const startX = this.state.currentStartingPosition.x;\r\n      const startY = this.state.currentStartingPosition.y;\r\n      const endX = this.state.currentEndingPosition.x;\r\n      const endY = this.state.currentEndingPosition.y;\r\n      const cloneGrid = this.state.currentGridTiles.slice();\r\n      let responseDijkstra = await dijkstra(startX, startY, endX, endY, cloneGrid);\r\n      return responseDijkstra;\r\n  };\r\n\r\n  visualizePath = async (cmd) => {\r\n    if(!this.state.currentlyAnimating) {\r\n      const moves = !cmd.localeCompare(\"findPath\") ? await this.getPath() : await this.createMaze();\r\n      const timer = ms => new Promise(res => setTimeout(res, ms));\r\n      this.setState({ currentlyAnimating: true })\r\n      for (let move in moves) {\r\n        if(!this.state.currentlyAnimating){\r\n          const emptyTileArray = this.generateEmptyTileArray(\"soft\");\r\n          this.setState({ currentGridTiles: emptyTileArray})\r\n          return;\r\n        }          \r\n          await timer(0.001);\r\n          const newArray = this.updatedTileArray(moves[move].x, moves[move].y, moves[move].state);\r\n          \r\n          this.setState({currentGridTiles: newArray});\r\n      }\r\n      this.setState({ currentlyAnimating: false })\r\n    }\r\n  }\r\n\r\n  createMaze = async () => {\r\n    let grid = this.state.currentGridTiles;\r\n    let start = this.state.currentStartingPosition;\r\n    let end = this.state.currentEndingPosition;\r\n    grid.map(row => {\r\n      row.map(tile => {\r\n          if (!(tile.x === start.x && tile.y === start.y) && !(tile.x === end.x && tile.y === end.y)) {\r\n              tile.weight = Math.random();\r\n              tile.wall = true;\r\n          }            \r\n      })\r\n    })\r\n    const cloneGrid = JSON.parse(JSON.stringify(this.state.currentGridTiles)); //create a copy - don't want to pass by reference and edit the same array\r\n    let responseMaze = await prim(this.state.currentStartingPosition, this.state.currentEndingPosition, cloneGrid);\r\n    return responseMaze;\r\n  }\r\n\r\n  displayHelp = async () => {\r\n    this.setState({\r\n      seeHelp: !this.state.seeHelp\r\n    })\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"gridWrapper\">\r\n        {this.state.seeHelp ? <PopUp toggle={this.displayHelp}/> : null}\r\n          <button onClick={() => {this.displayHelp()}}>          \r\n              Help\r\n          </button>        \r\n          <button\r\n            onClick={() => {\r\n              this.resetTileArray(\"hard\");\r\n            }}\r\n          >\r\n            Reset\r\n          </button>        \r\n          <div className=\"grid\">\r\n            {this.state.currentGridTiles &&\r\n              this.state.currentGridTiles.map((row) => {\r\n                return row.map((tile) => {\r\n                  const {\r\n                    key,\r\n                    x,\r\n                    y,\r\n                    handleMouseDown,\r\n                    handleMouseEnter,\r\n                    handleMouseUp,\r\n                    wall,\r\n                    path,\r\n                    exploring,\r\n                    explored,\r\n                    start,\r\n                    end,\r\n                  } = tile;\r\n                  return (\r\n                    <Tile\r\n                      key={key}\r\n                      x={x}\r\n                      y={y}\r\n                      handleMouseEnter={handleMouseEnter}\r\n                      wall={wall}\r\n                      path={path}\r\n                      exploring={exploring}\r\n                      explored={explored}\r\n                      handleMouseDown={handleMouseDown}\r\n                      handleMouseUp={handleMouseUp}\r\n                      start={start}\r\n                      end={end}\r\n                    />\r\n                  );\r\n                });\r\n              })}\r\n          </div>\r\n          <button\r\n            onClick={() => {\r\n              this.dijkstraButtonClick();\r\n            }}\r\n          >\r\n            Visualize Dijkstra\r\n          </button>\r\n          <button\r\n            onClick={() => {\r\n              this.generateMazeButtonClick();\r\n            }}\r\n          >\r\n            Generate Random Maze\r\n          </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from 'react'\r\nimport Spritesheet from 'react-responsive-spritesheet'\r\nimport './Header.css'\r\n\r\nconst Header = () => {\r\n        return (\r\n            <>\r\n                <div>\r\n                    <h1 className=\"Title\">PacFinder</h1>\r\n                </div>\r\n            </>\r\n        )\r\n}\r\nexport default Header;","import './App.css';\r\nimport Grid from './components/Grid'\r\nimport Header from './components/Header'\r\n\r\nfunction App() {\r\n  return (\r\n    <>\r\n    <div className='App'>\r\n      <Header/>\r\n      <Grid/>\r\n    </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}